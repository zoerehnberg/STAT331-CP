---
title: "Data Joins + Pivots + Factors"
format: 
  revealjs:
    theme: default
editor: source
embed-resources: true
---

```{r setup}
#| include: false
#| message: false
library(tidyverse)
library(palmerpenguins)
library(ggridges)
```

## Monday, April 22

Today we will...

-   Comments from Week 3
-   New Material
    -   Pivoting data with `tidyr`
    -   Joining data with `dplyr`
-   [PA 4: Military Spending](https://zoerehnberg.github.io/STAT331-S23/practice_activities/PA4.html)


## Comments from Week 3

+ The [`tidyverse`](https://www.tidyverse.org/packages/) package automatically loads `ggplot2`, `dplyr`, `readr`, etc. -- do not load these twice!

+ Do not use `mutate()` + `distinct()`, when you can use `summarize()`!
  + We want to pay attention to the **efficiency** of our code.


## `mutate()` vs `summarise()`

::: panel-tabset
### `mutate()`

![](images/mutate-sketch.JPG)

### `summarise()`

![](images/summarise-sketch.JPG){width=85%}
:::


# Data Layouts

## Tidy Data

Tidy data...

-   is rectangular.
-   has observations as rows and variables as columns.
-   **has different formats for different tasks.**

![R4DS](https://r4ds.hadley.nz/images/tidy-1.png)


## Consequences of Messy Data

![Allison Horst](https://www.openscapes.org/img/blog/tidydata/tidydata_2.jpg)

-   *Tidy*: use the same tools in similar ways for different datasets.
-   *Messy*: create unique tools that are difficult to generalize.


## Creating Tidy Data

We may need to **transform** our data to turn it into the **version of tidy** that is best for a task at hand.

![Allison Horst](https://www.openscapes.org/img/blog/tidydata/tidydata_4.jpg)


## Creating Tidy Data

Let's say we want to look at `mean` **cereal nutrients** based on `shelf`.

. . .

+ The data are in a **wide** format -- a separate column for each nutrient.
+ **Transforming** the data will make plotting easier.

```{r}
#| echo: true
#| eval: false
library(liver)
data(cereal)
head(cereal)
```

```{r}
#| eval: true
#| echo: false
library(liver)
data(cereal)
head(cereal) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "210px") |> 
  kableExtra::kable_styling(font_size = 30)
```


## Creating Tidy Data

::: panel-tabset

## Wide

```{r}
#| echo: true
#| code-line-numbers: "2-3"
#| code-fold: true
cereal_wide <- cereal |> 
  group_by(shelf) |> 
  summarise(across(calories:vitamins, mean))
```

```{r}
#| eval: true
#| echo: false
cereal_wide|> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "210px") |> 
  kableExtra::kable_styling(font_size = 30)
```

## Wide Plot

```{r}
#| echo: true
#| code-line-numbers: "5-8"
#| fig-height: 4
#| fig-width: 6
#| fig-align: center
#| code-fold: true
my_colors <- c("calories_col" = "steelblue", "sugars_col" = "orange3")

cereal_wide |> 
  ggplot() +
  geom_point(aes(x = shelf, y = calories, color = "calories_col")) +
  geom_line(aes(x = shelf, y = calories, color = "calories_col")) + 
  geom_point(aes(x = shelf, y = sugars, color = "sugars_col")) +
  geom_line(aes(x = shelf, y = sugars, color = "sugars_col")) +
  scale_color_manual(values = my_colors, labels = names(my_colors)) +
  labs(x = "Shelf", y = "", subtitle = "Mean Amount", color = "Nutrient")
```

## Long

```{r}
#| echo: true
#| code-line-numbers: "5-6"
#| code-fold: true
cereal_long<- cereal |> 
  pivot_longer(cols = calories:vitamins,
               names_to = "Nutrient",
               values_to = "Amount") |> 
  group_by(shelf, Nutrient) |> 
  summarise(mean_amount = mean(Amount))
```

```{r}
#| eval: true
#| echo: false
cereal_long |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "400px") |> 
  kableExtra::kable_styling(font_size = 30)
```

## Long Plot

```{r}
#| echo: true
#| code-line-numbers: "2-4"
#| fig-height: 4
#| fig-width: 6
#| fig-align: center
#| code-fold: true
cereal_long |> 
  ggplot(aes(x = shelf, 
             y = mean_amount, 
             color = Nutrient)) +
  geom_point() +
  geom_line() +
  labs(x = "Shelf", y = "", subtitle = "Mean Amount")
```
:::


# Pivoting Data

::: columns
::: column
![Kelsey Gonzalez](https://github.com/gadenbuie/tidyexplain/raw/main/images/static/png/original-dfs-tidy.png)
:::

::: column
![](https://github.com/gadenbuie/tidyexplain/raw/main/images/tidyr-pivoting.gif)
:::
:::


## Manual Method

Consider daily rainfall observed in SLO in January 2023.

+ The data is in a human-friendly form (like a calendar).
+ Each week has a row, and each day has a column.

![[Data source](cesanluisobispo.ucanr.edu)](images/slo-rainfall.jpg)

How would you **manually** convert this to **long format**?


## Manual Method: Steps

::: incremental
0.  Keep the column `Week`.
1.  Create a new column `Day_of_Week`.
2.  Create a new column `Rainfall` (hold daily rainfall values).
3.  Now we have three columns -- move Sunday values over.
:::

. . .

<center> 

![](images/pivot_rain1.png){width=25%}

</center> 


## Manual Method: Steps

0.  Keep the column `Week`.
1.  Create a new column `Day_of_Week`.
2.  Create a new column `Rainfall` (hold daily rainfall values).
3.  Now we have three columns -- move Sunday values over.
4.  Duplicate `Week` 1-5 and copy Monday values over.

<center> 

![](images/pivot_rain2.png){width=25%}
</center> 


## Manual Method: Steps

0.  Keep the column `Week`.
1.  Create a new column `Day_of_Week`.
2.  Create a new column `Rainfall` (hold daily rainfall values).
3.  Now we have three columns -- move Sunday values over.
4.  Duplicate `Week` 1-5 and copy Monday values over.
5.  Duplicate `Week` 1-5 and copy Tuesday values over.

## Manual Method: Steps

0.  Keep the column `Week`.
1.  Create a new column `Day_of_Week`.
2.  Create a new column `Rainfall` (hold daily rainfall values).
3.  Now we have three columns -- move Sunday values over.
4.  Duplicate `Week` 1-5 and copy Monday values over.
5.  Duplicate `Week` 1-5 and copy Tuesday values over.
6.  Continue for the rest of the days of the week.

## Manual Method: Steps

0.  Keep the column `Week`.
1.  Create a new column `Day_of_Week`.
2.  Create a new column `Rainfall` (hold daily rainfall values).
3.  Now we have three columns -- move Sunday values over.
4.  Duplicate `Week` 1-5 and copy Monday values over.
5.  Duplicate `Week` 1-5 and copy Tuesday values over.
6.  Continue for the rest of the days of the week.
7.  You may want to `arrange()` by `Week` to get the rainfall values chronological order.



## Computational Approach

![](images/slo-rainfall-sketch.png)

We can use `pivot_longer()` to turn a **wide** dataset into a **long(er)** dataset.


## `pivot_longer()`

Take a **wide** dataset and turn it into a **long** daaset.

+ `cols` -- specify the columns that should be pivoted.
  + Do **not** include the names of ID columns (columns to not be pivoted).
+ `names_to` -- the name of the new column containing the old column names.
+ `values_to` -- the name of the new column containing the old  column values.


## `pivot_longer()`

```{r}
#| echo: true
#| eval: false
slo_rainfall |> 
  pivot_longer(cols      = Sunday:Saturday,
               names_to  = "Day_of_Week",
               values_to = "Daily_Rainfall")
```

```{r}
#| eval: true
#| echo: false
library(readxl)
slo_rainfall <- read_xlsx("data/2023-rainfall-slo.xlsx")

slo_rainfall |> 
  mutate(across(Sunday:Saturday, as.numeric)) |> 
  pivot_longer(cols      = Sunday:Saturday,
               names_to  = "Day_of_Week",
               values_to = "Daily_Rainfall")|> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "500px") |> 
  kableExtra::kable_styling(font_size = 30)
```


## `pivot_wider()`

Take a **long** dataset and turn it into a **wide** daaset.

+ `id_cols` -- specify the column(s) that contain the ID for unique rows in the wide dataset.
+ `names_from` -- the name of the column containing the new column names.
+ `values_from` -- the name of the column containing the new  column values.


## `pivot_wider()`

Let's say we calculate the `mean` amount of `protein` for cereals on each `shelf` and for each `manuf`.

```{r}
#| echo: true
#| eval: false
mean_protein <- cereal |> 
  group_by(manuf, shelf) |> 
  summarize(mean_protein = mean(protein))
```

```{r}
#| eval: true
#| echo: false
mean_protein <- cereal |> 
  group_by(manuf, shelf) |> 
  summarize(mean_protein = mean(protein))

mean_protein |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "400px") |> 
  kableExtra::kable_styling(font_size = 30)
```


## `pivot_wider()`

We can make this dataset more easily readable...

. . .

```{r}
#| eval: false
#| echo: true
mean_protein |> 
  arrange(shelf) |> 
  pivot_wider(id_cols = manuf,
              names_from = shelf,
              values_from = mean_protein)
```

```{r}
#| eval: true
#| echo: false
mean_protein |> 
  arrange(shelf) |> 
  pivot_wider(id_cols = manuf,
              names_from = shelf,
              values_from = mean_protein) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "420px") |> 
  kableExtra::kable_styling(font_size = 30)
```


## Better names in `pivot_wider()`


```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "6"
mean_protein |> 
  arrange(shelf) |> 
  pivot_wider(id_cols = manuf,
              names_from = shelf,
              values_from = mean_protein,
              names_prefix = "Shelf_")
```

```{r}
#| eval: true
#| echo: false
mean_protein |> 
  arrange(shelf) |> 
  pivot_wider(id_cols = manuf,
              names_from = shelf,
              values_from = mean_protein,
              names_prefix = "Shelf_") |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "420px") |> 
  kableExtra::kable_styling(font_size = 30)
```


# Data Joins

## Relational Data

Multiple, interconnected tables of data are called **relational**.

+ It is the *relation* between datasets, not just the individual datasets themselves, that are important.

![IMDb movie relational data](images/imdb_relational.png)

```{r imdb-data}
#| eval: false
#| include: false
#| message: false
#| warning: false
library(RMariaDB)
library(dm)
`
# IMDb
con <- dbConnect(
  drv = RMariaDB::MariaDB(), 
  username = "guest",
  password = "relational", 
  host = "relational.fit.cvut.cz", 
  port = 3306,
  dbname = "imdb_small")
dbListTables(con)

my_dm <- dm_from_src(con)

actors <- my_dm$actors |> 
  as.data.frame()
write_csv(actors, "data/actors.csv", na = "")

directors <- my_dm$directors |> 
  as.data.frame()
write_csv(directors, "data/directors.csv", na = "")

directors_genres <- my_dm$directors_genres |> 
  as.data.frame()
write_csv(directors_genres, "data/directors_genres.csv", na = "")

movies <- my_dm$movies |> 
  as.data.frame()
write_csv(movies, "data/movies.csv", na = "")

movies_directors <- my_dm$movies_directors |> 
  as.data.frame()
write_csv(movies_directors, "data/movies_directors.csv", na = "")

movies_genres <- my_dm$movies_genres |> 
  as.data.frame()
write_csv(movies_genres, "data/movies_genres.csv", na = "")

roles <- my_dm$roles |> 
  as.data.frame()
write_csv(roles, "data/roles.csv", na = "")

dbDisconnect(con)
rm(con, my_dm)
```

```{r imdb-data2}
#| eval: true
#| include: false
#| message: false
#| warning: false

actors <- read_csv("data/actors.csv")
directors <- read_csv("data/directors.csv")
directors_genres <- read_csv("data/directors_genres.csv")
movies <- read_csv("data/movies.csv")
movies_directors <- read_csv("data/movies_directors.csv")
movies_genres <- read_csv("data/movies_genres.csv")
roles <- read_csv("data/roles.csv")
```


## Data Joins

We can **combine** (join) data tables based on their relations.

::: columns
::: column
**Mutating joins**

Add *variables* from a new dataframe to observations in an existing dataframe.

`full_join()`, `left_join()`, `right_join()`, `inner_join()`, `outer_join()`
:::

::: column
**Filtering Joins**

Filter *observations* based on values in new dataframe.

`semi_join()`, `anti_join()`
:::
:::


## Keys

A key uniquely identifies an observation in a data set.

+ To combine (join) two datasets, the **key** needs to be present in both.

. . .

![](images/imdb-keys.png)


## `inner_join()`

Keeps obsertvations when their keys are present in **both** datasets.

:::: {.columns}
::: {.column width="50%"}
![](images/join_xy.png)
:::
::: {.column width="50%"}
![](images/inner_join.png)

:::
::::


## `inner_join()`: IMDb Example

```{r}
directors_genres_subset <- directors_genres |>
  filter(director_id %in% c(429, 2931, 11652, 14927, 15092)) |> 
  group_by(director_id) |> 
  slice_max(order_by = prob, n = 2, with_ties = F)

movies_directors_subset <- movies_directors |> 
  filter(director_id %in% c(429, 9247, 11652, 14927, 15092))

directors_subset <- directors |> 
  filter(id %in% c(429, 9247, 11652, 14927, 15092))
```

:::: {.columns}
::: {.column width="50%"}

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: false
directors_genres
```

```{r}
#| eval: true
#| echo: false
directors_genres_subset |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "160px") |> 
  kableExtra::kable_styling(font_size = 30)
```

:::
::: {.column width="50%"}

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: false
movies_directors
```

```{r}
#| eval: true
#| echo: false
movies_directors_subset |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "160px") |> 
  kableExtra::kable_styling(font_size = 30)
```

:::
::::

<font size = 6>

ID: 429, **2931**, 11652, 14927, 15092  &emsp; &emsp; &ensp;  ID: 429, **9247**, 11652, 14927, 15092

</font>

. . .

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: false
inner_join(directors_genres, movies_directors)
```

```{r}
#| eval: true
#| echo: false
inner_join(directors_genres_subset, movies_directors_subset) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "160px") |> 
  kableExtra::kable_styling(font_size = 30)
```

<font size = 6>

ID: 429, ~~**2931**~~, ~~**9247**~~, 11652, 14927, 15092

</font>


## `inner_join()`: IMDb Example

What if our **key** does not have the same name?

:::: {.columns}
::: {.column width="50%"}

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: false
directors_genres
```

```{r}
#| eval: true
#| echo: false
directors_genres_subset |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "170px") |> 
  kableExtra::kable_styling(font_size = 30)
```

:::
::: {.column width="50%"}

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: false
directors
```

```{r}
#| eval: true
#| echo: false
directors_subset |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "170px") |> 
  kableExtra::kable_styling(font_size = 30)
```

:::
::::

. . .

:::: {.columns}
::: {.column width="60%"}

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "3"
inner_join(directors_genres, 
           directors, 
           join_by(director_id == id))
```

```{r}
#| eval: true
#| echo: false
inner_join(directors_subset,
           directors_genres_subset,
           join_by(id == director_id)) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "170px") |> 
  kableExtra::kable_styling(font_size = 30)
```

:::
::: {.column width="40%"}
<font size = 6>
Join by different variables on `dataX` and `dataY`: `join_by(a == b)` will match `dataX$a` to `dataY$b`.

</font>
:::
::::

## Piping Joins

Remember: the dataset you pipe in becomes the **first argument** of the function you are piping into!

+ So if you are using a pipe, you will only be specifying the **right** dataset inside the `join` function.

. . .

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: false
inner_join(directors_genres, movies_directors)
```

...is equivalent to...

```{r}
#| eval: false
#| echo: true
#| code-line-numbers: false
directors_genres |> 
  inner_join(movies_directors)
```



## More Mutating Joins

-   `left_join()` -- keep only (and all) observations present in the left data set

-   `right_join()` -- keep only (and all) observations present in the right data set 

-   `full_join()` -- keep only (and all) observations present in **both** data sets

<center>

![](images/joins.png){width=70%}

</center>


## More Mutating Joins

Which directors would **remain** for each of the following?

<font size = 6>

-   `left_join(directors_genres, movies_directors)`
-   `right_join(directors_genres, movies_directors)`
-   `full_join(directors_genres, movies_directors)`

</font>

::: columns
::: column
```{r}
#| eval: false
#| echo: true
directors_genres |> 
  distinct(director_id)
```

```{r}
#| eval: true
#| echo: false
directors_genres_subset |> 
  distinct(director_id) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "320px") |> 
  kableExtra::kable_styling(font_size = 30)
```

:::

::: column
```{r}
#| eval: false
#| echo: true
movies_directors |> 
  distinct(director_id)
```

```{r}
#| eval: true
#| echo: false
movies_directors_subset |> 
  distinct(director_id) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "320px") |> 
  kableExtra::kable_styling(font_size = 30)
```
:::
:::


## Filtering Joins: `semi_join()`

Keeps observations when their keys are present in **both** datasets, **but only keeps variables from the first dataset**.

:::: {.columns}
::: {.column width="60%"}

![](images/semi1.png)
:::
::: {.column width="15%"}

<br>

::: {.r-fit-text}
&rarr; &emsp;
:::

:::
::: {.column width="25%"}

![](images/semi2.png)

:::
::::


## Filtering Joins: `semi_join()`

::: panel-tabset

### `semi_join()`

```{r}
#| echo: true
#| eval: false
directors_genres |> 
  semi_join(movies_directors)
```

```{r}
#| eval: true
#| echo: false
semi_join(directors_genres_subset, movies_directors_subset) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "320px") |> 
  kableExtra::kable_styling(font_size = 30)
```

Movie Directors: 429, ~~**2931**~~, 11652, 14927, 15092

### Connection to `filter()`

```{r}
#| echo: true
#| eval: false
directors_genres |>
  filter(director_id %in% movies_directors$director_id)
```

```{r}
#| eval: true
#| echo: false
directors_genres_subset |>
  filter(director_id %in% movies_directors_subset$director_id) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "320px") |> 
  kableExtra::kable_styling(font_size = 30)
```

:::


## Filtering Joins: `anti_join()`

**Removes** observations when their keys are present in **both** datasets, and **only keeps variables from the first dataset**.

:::: {.columns}
::: {.column width="60%"}

![](images/semi1.png)
:::
::: {.column width="15%"}

<br>

::: {.r-fit-text}
&rarr; &emsp;
:::

:::
::: {.column width="25%"}

<br>

![](images/anti2.png)

:::
::::


## Filtering Joins: `anti_join()`

::: panel-tabset

### `anti_join()`

```{r}
#| echo: true
#| eval: false
directors_genres |> 
  anti_join(movies_directors)
```

```{r}
#| eval: true
#| echo: false
anti_join(directors_genres_subset, movies_directors_subset) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "200px") |> 
  kableExtra::kable_styling(font_size = 30)
```

Movie Directors: ~~429~~, **2931**, ~~11652~~, ~~14927~~, ~~15092~~

### Connection to `filter()`

```{r}
#| echo: true
#| eval: false
directors_genres |>
  filter(!director_id %in% movies_directors$director_id)
```

```{r}
#| eval: true
#| echo: false
directors_genres_subset |>
  filter(!director_id %in% movies_directors_subset$director_id) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "200px") |> 
  kableExtra::kable_styling(font_size = 30)
```

:::


## [PA 4: Military Spending](https://zoerehnberg.github.io/STAT331-S23/practice_activities/PA4.html)

Today you will be tidying messy data to explore the relationship between countries of the world and military spending.

+ **Due Wednesday, 4/24 at 10:00am**


## To do...

-   **PA 4: Military Spending**
    -   Due Wednesday, 4/24 at 10:00am



## Wednesday, April 24

Today we will...

-   New Material
    -   Extensions to Relational Data
    -   Factors with `forcats`
    -   Clean Variable Names
    -   Lifecycle Stages
-   Lab 4: Childcare Costs in California


# Extensions to Relational Data


## Relational Data

When we work with multiple tables of data, we say we are working with **relational data**.

+ It is the *relations*, not just the individual datasets, that are important.

. . .

When we work with relational data, we rely on **keys**.

-   A key uniquely identifies an observation in a dataset.
-   A key allows us to relate datasets to each other


## IMDb Movies Data

![](images/imdb-keys.png)

**How can we find each director's active years?**


## Joining Multiple Data Sets

::: panel-tabset
### Data

:::: {.columns}
::: {.column width="50%"}
```{r}
#| echo: true
directors[1:4,]
```
:::
::: {.column width="50%"}
```{r}
#| echo: true
movies_directors[1:4,]
```
:::
::::

:::: {.columns}
::: {.column width="25%"}

:::
::: {.column width="50%"}
```{r}
#| echo: true
movies[1:4,]
```
:::
::::

### Sketch

```{r}
#| out-width: "90%"
#| fig-align: center
knitr::include_graphics("images/multiple_joins.png")
```

### 1st + 2nd

```{r}
#| echo: true
#| eval: false
movies_directors |> 
  inner_join(directors, 
             join_by(director_id == id))
```


```{r}
#| eval: true
#| echo: false
movies_directors |> 
  inner_join(directors, 
             join_by(director_id == id)) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "400px") |> 
  kableExtra::kable_styling(font_size = 30)
```

### + 3rd

```{r}
#| echo: true
#| eval: false
movies_directors |> 
  inner_join(directors, 
             join_by(director_id == id)) |> 
  inner_join(movies,
             join_by(movie_id == id)) |> 
  rename(movie_name = name)
```

```{r}
#| eval: true
#| echo: false
movies_directors |> 
  inner_join(directors, 
             join_by(director_id == id)) |> 
  inner_join(movies,
             join_by(movie_id == id)) |> 
  rename(movie_name = name) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "300px") |> 
  kableExtra::kable_styling(font_size = 30)
```

:::


## Joining on Multiple Variables

Consider the `rodent` data from Lab 2.

+ We want to add `species_id` to the rodent measurements.

```{r}
rodent <- read_csv("../../lab_assignments/lab2/surveys.csv")
species <- rodent |> 
  select(genus:taxa, species_id) |> 
  distinct()

measurements <- rodent |> 
  select(genus, species, sex:weight) |> 
  rename(genus_name = genus)
```

::: panel-tabset

## Species

```{r}
#| echo: true
#| eval: false
species
```

```{r}
#| eval: true
#| echo: false
species |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "300px") |> 
  kableExtra::kable_styling(font_size = 30)
```

## Measurements

```{r}
#| echo: true
#| eval: false
measurements
```

```{r}
#| eval: true
#| echo: false
measurements[1:100,] |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "300px") |> 
  kableExtra::kable_styling(font_size = 30)
```

## Join by `species` + `genus`

```{r}
#| echo: true
#| eval: false
species |> 
  full_join(measurements,
            join_by(species == species, 
                    genus == genus_name))
```

```{r}
#| eval: true
#| echo: false
species |> 
  full_join(measurements[1:100,],
            join_by(species == species, 
                    genus == genus_name)) |> 
  knitr::kable() |> 
  kableExtra::scroll_box(height = "200px") |> 
  kableExtra::kable_styling(font_size = 30)
```

:::

# Factor Variables


## What is a factor variable?

Factors are used for

1. categorical variables with a fixed and known set of possible values.
  + E.g., `day_born` = Sunday, Monday, Tuesday, ..., Saturday
2. displaying character vectors in non-alphabetical order.


## Eras Tour

Let's consider songs that Taylor Swift played on her Eras Tour.

I have randomly selected 25 songs (and their albums) to consider.

```{r}
#| echo: false
set.seed(2)
full_eras <- read_excel("data/TS_data.xlsx", sheet = 1)
eras_data <- full_eras |> 
  slice_sample(n = 25) |> 
  select(Song, Album)
```

```{r}
#| echo: true
eras_data |> 
  slice_head(n = 10)
```


## Creating a Factor -- Base `R`

A **character** vector:

```{r}
#| echo: true
eras_data |> 
  pull(Album)
```

. . .

A **factor** vector:

```{r}
#| echo: true
eras_data |> 
  pull(Album) |> 
  factor()
```



## Creating a Factor -- Base `R`

When you create a factor variable from a vector...

+ Every unique element in the vector becomes a **level**.
+ The levels are ordered alphabetically.
+ The elements are no longer displayed in quotes.


## Creating a Factor -- Base `R`

You can **specify the order of the levels** with the `level` argument.

```{r}
#| echo: true
eras_data |> 
  pull(Album) |> 
  factor(levels = c("Fearless","Speak Now","Red","1989",
                    "Reputation","Lover","Folklore",
                    "Evermore","Midnights"))
```

## `forcats`

:::: {.columns}
::: {.column width="80%"}
We use this package to...

+ turn character variables into factors.

+ make factors by discretizing numeric variables.

+ rename or reorder the levels of an existing factor.
:::
::: {.column width="20%"}
```{r}
#| fig-align: center
knitr::include_graphics("https://github.com/rstudio/hex-stickers/blob/main/thumbs/forcats.png?raw=true")
```
:::
::::

::: callout-note
The packages `forcats` ("for categoricals") helps wrangle categorical variables.

  + `forcats` loads with `tidyverse`!
:::


## Creating a Factor -- `fct`

With `fct()`, the levels are automatically ordered in the **order of first appearance**.

```{r}
#| echo: true
eras_data |> 
  pull(Album) |> 
  fct()
```


## Creating a Factor -- NOTE

To change a column type to factor, you must wrap `fct()` in a `mutate()` call.

```{r}
#| echo: true
#| eval: false
eras_data <- eras_data |> 
  mutate(Album = fct(Album))
```

. . .

I am just using `pull()` to display the outcome.

```{r}
#| echo: true
eras_data |> 
  pull(Album) |> 
  fct()
```


## Creating a Factor -- `fct`

You can still **specify the order of the levels** with `level`.

```{r}
#| echo: true
eras_data |> 
  pull(Album) |> 
  fct(levels = c("Fearless","Speak Now","Red","1989",
                 "Reputation","Lover","Folklore",
                 "Evermore","Midnights"))
```


## Creating a Factor -- `fct`

You can also **specify non-present levels**.

```{r}
#| echo: true
eras_data |> 
  pull(Album) |> 
  fct(levels = c("Taylor Swift",
                 "Fearless","Speak Now","Red","1989",
                 "Reputation","Lover","Folklore",
                 "Evermore","Midnights",
                 "The Tortured Poets Department")) 
```

```{r}
#| echo: false
eras_data <- eras_data |> 
  mutate(Album = fct(Album,
                     levels = c("Taylor Swift",
                                "Fearless","Speak Now","Red",
                                "1989","Reputation","Lover",
                                "Folklore","Evermore","Midnights",
                                "The Tortured Poets Department")))
```


## Re-coding a Factor -- `fct_recode`

Oops, we have a typo in some of our levels! We change existing levels with the syntax `<new level> = <old level>`.

. . .

```{r}
#| echo: true
eras_data |>
  pull(Album) |> 
  fct_recode("folklore" = "Folklore",
             "evermore" = "Evermore",
             "reputation" = "Reputation")
```

```{r}
#| echo: false
eras_data <- eras_data |>
  mutate(Album = fct_recode(.f = Album,
                            "folklore" = "Folklore",
                            "evermore" = "Evermore",
                            "reputation" = "Reputation"))
```

**Non-specified levels are not re-coded.**


## Re-coding a Factor -- `case_when`

We have similar functionality with the `case_when()` function...

. . .

```{r}
#| echo: true
eras_data |>
  mutate(Album = case_when(Album == "Folklore" ~ "folklore",
                           Album == "Evermore" ~ "evermore",
                           Album == "Reputation" ~ "reputation",
                           .default = Album),
         Album = fct(Album)) |> 
  pull(Album)
```



## Collapsing a Factor --`fct_collapse`

Collapse multiple existing levels of a factor with the syntax `<new level> = c(<old levels>)`.

. . .

```{r}
#| echo: true
eras_data |> 
  mutate(Genre = fct_collapse(.f= Album,
                       "country pop" = c("Taylor Swift", "Fearless"),
                       "pop rock" = c("Speak Now","Red"),
                       "electropop" = c("1989","reputation","Lover"),
                       "folk pop" = c("folklore","evermore"),
                       "alt-pop" = "Midnights")) |> 
  slice_sample(n = 6)
```


## Re-leveling a Factor --`fct_relevel`

Change the **order** of the levels of an existing factor.

::: panel-tabset

### Original

```{r}
#| echo: true
eras_data |>
  pull(Album) |> 
  levels()
```

### Ordered by Copies Sold

```{r}
#| echo: true
eras_data |> 
  pull(Album) |>
  fct_relevel(c("Fearless","1989","Taylor Swift",
                "Speak Now","Red","Midnights","reputation",
                "folklore","Lover","evermore")) |> 
  levels()
```

Unspecified levels remain in the same order at the **end**.

:::


## Re-ordering Factors in `ggplot2`

::: panel-tabset

### Original

The bars follow the default factor levels.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "2"
full_eras |> 
  mutate(Album = fct(Album)) |> 
  ggplot() +
  geom_bar(aes(y = Album,
               fill = Album)) +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "Number of Songs",
       y = "",
       subtitle = "Album",
       title = "Songs Played on the Eras Tour")
```

### Plot

```{r}
#| echo: false
full_eras |> 
  mutate(Album = fct(Album)) |> 
  ggplot() +
  geom_bar(aes(y = Album,
               fill = Album)) +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "Number of Songs",
       y = "",
       subtitle = "Album",
       title = "Songs Played on the Eras Tour")
```

### Specify Levels

We can order factor levels to order the bar plot.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "2-6"
full_eras |> 
  mutate(Album = fct(Album,
                     levels = c("Fearless","Speak Now","Red",
                                "1989","Reputation","Lover",
                                "Folklore","Evermore",
                                "Midnights"))) |> 
  ggplot() +
  geom_bar(aes(y = Album,
               fill = Album)) +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "Number of Songs",
       y = "",
       subtitle = "Album",
       title = "Songs Played on the Eras Tour")
```

### Plot

```{r}
#| echo: false
full_eras |> 
  mutate(Album = fct(Album,
                     levels = c("Fearless","Speak Now","Red",
                                "1989","Reputation","Lover",
                                "Folklore","Evermore",
                                "Midnights"))) |> 
  ggplot() +
  geom_bar(aes(y = Album,
               fill = Album)) +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(x = "Number of Songs",
       y = "",
       subtitle = "Album",
       title = "Songs Played on the Eras Tour")
```

:::


## Re-ordering Factors in `ggplot2`

```{r}
full_eras <- full_eras |> 
  mutate(Album = fct(Album,
                     levels = c("Fearless","Speak Now","Red",
                                "1989","Reputation","Lover",
                                "Folklore","Evermore",
                                "Midnights")))
```

::: panel-tabset

### Original

The ridge plots follow the order of the factor levels.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "3"
full_eras |> 
  ggplot(aes(x = Length, 
             y = Album, 
             fill = Album)) +
  geom_density_ridges() +
  theme_minimal() +
  theme(legend.position = "none")+
  labs(x = "Song Length (mins)",
       y = "",
       subtitle = "Album",
       title = "Songs Played on the Eras Tour")
```

### Plot

```{r}
#| echo: false
library(ggridges)
full_eras |> 
  ggplot(aes(x = Length, 
             y = Album, 
             fill = Album)) +
  geom_density_ridges() +
  theme_minimal() +
  theme(legend.position = "none")+
  labs(x = "Song Length (mins)",
       y = "",
       subtitle = "Album",
       title = "Songs Played on the Eras Tour")
```

### `fct_reorder()`

Inside `ggplot()`, we can order factor levels by a summary value.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "3-5"
full_eras |> 
  ggplot(aes(x = Length, 
             y = fct_reorder(.f = Album,
                             .x = Length,
                             .fun = mean), 
             fill = Album)) +
  geom_density_ridges() +
  theme_minimal() +
  theme(legend.position = "none")+
  labs(x = "Song Length (mins)",
       y = "",
       subtitle = "Album",
       title = "Songs Played on the Eras Tour")
```

### Plot

```{r}
#| echo: false
full_eras |> 
  ggplot(aes(x = Length, 
             y = fct_reorder(.f = Album,
                             .x = Length,
                             .fun = mean), 
             fill = Album)) +
  geom_density_ridges() +
  theme_minimal() +
  theme(legend.position = "none")+
  labs(x = "Song Length (mins)",
       y = "",
       subtitle = "Album",
       title = "Songs Played on the Eras Tour")
```

:::


## Re-ordering Factors in `ggplot2`

::: panel-tabset

### Original

```{r}
full_eras <- full_eras |> 
  mutate(Single = if_else(Single == "Y", 1, 0))
```

The legend follows the order of the factor levels.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: "7"
full_eras |> 
  filter(!Album %in% c("1989","Fearless")) |> 
  group_by(Album, Single) |> 
  summarise(avg_len = mean(Length)) |> 
  ggplot(aes(x = Single, 
             y = avg_len, 
             color = Album)) +
  geom_point(size = 1.5) +
  geom_line() +
  theme_minimal() +
  scale_x_continuous(breaks = c(0,1),
                     labels = c("No","Yes")) +
  labs(y = "",
       subtitle = "Average Song Length",
       color = "Album")
```

### Plot

```{r}
#| echo: false
full_eras |> 
  filter(!Album %in% c("1989","Fearless")) |> 
  group_by(Album, Single) |> 
  summarise(avg_len = mean(Length)) |> 
  ggplot(aes(x = Single, 
             y = avg_len, 
             color = Album)) +
  geom_point(size = 1.5) +
  geom_line() +
  theme_minimal() +
  scale_x_continuous(breaks = c(0,1),
                     labels = c("No","Yes")) +
  labs(y = "",
       subtitle = "Average Song Length",
       color = "Album")
```

### `fct_reorder2()`

Inside `ggplot()`, we can order factor levels by the $y$ values associated with the largest $x$ values.

```{r}
#| echo: true
#| eval: false
#| code-line-numbers: 7-9
full_eras |> 
  filter(!Album %in% c("1989","Fearless")) |> 
  group_by(Album, Single) |> 
  summarise(avg_len = mean(Length)) |> 
  ggplot(aes(x = Single, 
             y = avg_len, 
             color = fct_reorder2(.f = Album,
                                  .x = Single,
                                  .y = avg_len))) +
  geom_point(size = 1.5) +
  geom_line() +
  theme_minimal() +
  scale_x_continuous(breaks = c(0,1),
                     labels = c("No","Yes")) +
  labs(y = "",
       subtitle = "Average Song Length",
       color = "Album")
```

### Plot

```{r}
#| echo: false
full_eras |> 
  filter(!Album %in% c("1989","Fearless")) |> 
  group_by(Album, Single) |> 
  summarise(avg_len = mean(Length)) |> 
  ggplot(aes(x = Single, 
             y = avg_len, 
             color = fct_reorder2(.f = Album,
                                  .x = Single,
                                  .y = avg_len))) +
  geom_point(size = 1.5) +
  geom_line() +
  theme_minimal() +
  scale_x_continuous(breaks = c(0,1),
                     labels = c("No","Yes")) +
  labs(y = "",
       subtitle = "Average Song Length",
       color = "Album")
```

::: 



# `janitor` Package


## Clean Variable Names with [`janitor`](https://sfirke.github.io/janitor/)

```{r}
#| include: false
library(readxl)
library(tidyverse)
military <- read_xlsx("../../practice_activities/gov_spending_per_capita.xlsx", 
                sheet = "Share of Govt. spending", 
                skip  = 7, 
                n_max  = 191)

military_clean <- military |> 
  mutate(across(`1988`:`2019`,
                ~ na_if(.x, y = ". .")),
         across(`1988`:`2019`,
                ~ na_if(.x, y = "xxx")))
```

Data from external sources likely has variable names not ideally formatted for R.

Names may...

+ contain spaces.
+ start with numbers.
+ start with a mix of capital and lower case letters.

. . .

```{r}
#| eval: true
#| echo: true
names(military)[1:12]
```


## Clean Variable Names with [`janitor`](https://sfirke.github.io/janitor/)


The `janitor` package converts all variable names in a dataset to *snake_case*.

Names will...

+ start with a lower case letter.
+ have spaces filled in with `_`.

```{r}
#| eval: true
#| echo: true
#| code-line-numbers: "3-5"
library(janitor)
military_clean_names <- military |> 
  clean_names()

names(military_clean_names)[1:12]
```



# Lifecycle Stages

## Lifceycle Stages

As packages get updated, the functions and function arguments included in those packages will change.

+ The accepted syntax for a function may change.
+ A function/functionality may disappear.

![[Learn more about lifecycle stages](https://lifecycle.r-lib.org/articles/stages.html) of packages, functions, function arguments in R.](images/lifecycle.png)


## Lifceycle Stages

<center>

![](images/summarize_lifecycle.png){width=70%}

</center>

## Deprecated Functions

A **deprecated** functionality has a better alternative available and is scheduled for removal.

+ You get a warning telling you what to use instead.

. . .

```{r}
#| warning: true
#| message: true
#| echo: true
#| code-line-numbers: "2"
military_clean |> 
  filter(across(Notes:`2019`, is.na)) |> 
  slice_head(n = 3) |> 
  select(1:8)
```


## Deprecated Functions

You **should not** use deprecated functions!

Instead, we use...

```{r}
#| echo: true
#| code-line-numbers: "2"
military_clean |>
  filter(if_all(Notes:`2019`, ~ is.na(.x))) |> 
  slice_head(n = 3) |> 
  select(1:8)
```


## Superceded Functions

A **superseded** functionality has a better alternative, but is not going away.

+ This is a softer alternative to deprecation.
+ A superseded function will not give a warning (since thereâ€™s no risk if you keep using it), but the documentation will give you a recommendation.



## [Lab 4: Childcare Costs in California](https://zoerehnberg.github.io/STAT331-S23/lab_assignments/lab4/LA4_childcare.html)



## To do...

-   **Lab 4: Childcare Costs in California**
    -   Due Saturday (4/27) at 11:59pm
-   **Read Chapter 5: Strings + Dates**
    -   **Check-in 5.1 - 5.2** due Monday (4/29) at 10:00am
